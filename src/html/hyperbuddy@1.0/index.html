<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link
            rel="icon"
            type="image/png"
            href="http://arweave.net/zMT0qotUQUmPUYhGcgLr80XhG7GRmYXeLWWGitok6Ao"
        />
        <link
            href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
            rel="stylesheet"
        />
        <link rel="stylesheet" href="../../styles.css" />

        <title>HyperBEAM</title>
    </head>
    <body>
        <div class="view-wrapper">
            <div class="header">
                <div class="header-hyperbeam-chain">
                    <video autoplay muted loop playsinline width="500">
                        <source
                            src="https://arweave.net/kvebTQY2E5J7Zx-SSnsbwxIqS0-BxII9Bb0bQc__Rmg"
                            type="video/mp4"
                        />
                    </video>
                </div>
                <div class="header-main">
                    <div class="header-left">
                        <div class="video-container">
                            <video
                                autoplay
                                muted
                                loop
                                playsinline
                                width="500"
                                class="light-video"
                            >
                                <source
                                    src="https://arweave.net/ewmiCoSJpWpNv02F7AW5ZCp4meyaJxZHbOD4WEsuDFY"
                                    type="video/mp4"
                                />
                                Your browser does not support the video tag.
                            </video>
                        </div>
                    </div>
                </div>
                <div class="subheader">
                    <div class="subheader-value">
                        <p>Status:</p>
                        <div class="subheader-indicator-wrapper">
                            <div class="subheader-indicator"></div>
                            <p>Live</p>
                        </div>
                    </div>
                    <div class="subheader-value">
                        <p>Operator:</p>
                        <button id="operator-action" disabled="true">
                            Loading...
                        </button>
                    </div>
                </div>
            </div>

            <div class="explorer-view">
                <div class="signature-wrapper border-wrapper-primary">
                    <div class="signature-line">
                        <span>Signature</span>
                        <p>-</p>
                    </div>
                    <div class="signature-line">
                        <span>Signer</span>
                        <p>-</p>
                    </div>
                </div>
                <div class="explorer-view-flex">
                    <div class="explorers-wrapper">
                        <div class="explorer-wrapper">
                            <div class="explorer-header">
                                <p>Links</p>
                            </div>
                            <div id="links-explorer" class="explorer"></div>
                            <div class="explorer-footer">
                                <p id="links-explorer-footer-value">
                                    (0) Links
                                </p>
                            </div>
                        </div>

                        <div class="explorer-wrapper">
                            <div class="explorer-header">
                                <p>Signed Headers</p>
                            </div>
                            <div
                                id="signed-headers-explorer"
                                class="explorer"
                            ></div>
                            <div class="explorer-footer">
                                <p id="headers-explorer-footer-value">
                                    (0) Headers
                                </p>
                            </div>
                        </div>
                    </div>

                    <!-- <div class="visual-wrapper border-wrapper-primary">

                    </div> -->
                </div>
            </div>
        </div>

        <script>
            /**
             * Reconstruct the exact "signature base string" for a single entry:
             * 1) the raw signature-input entry (label=(...);alg="…";keyid="…"[;tag="…"])
             * 2) one line per covered field: "name: value" or "(status): 200"
             */
            function buildSigningString(entry, parsedHeaders, response) {
                // Find the raw entry text:
                const rawEntry = response.signatureInputRaw
                    .split(/\s*,\s*/)
                    .find((e) => e.startsWith(entry.label + "="));
                // Build each covered line
                const lines = entry.fields.map((f) => {
                    if (f.toLowerCase() === "status") {
                        return `(status): ${response.status}`;
                    }
                    const name = f.toLowerCase();
                    const val = parsedHeaders[name]?.data ?? "";
                    return `${name}: ${val}`;
                });
                return rawEntry + "\n" + lines.join("\n");
            }

            /**
             * Verify the HTTP Message Signature on the given response.
             * @param {{[header:string]:{data:string}}} parsedHeaders
             * @param {Response} response
             * @returns {Promise<boolean>}
             */
            async function verifySignature(parsedHeaders, response) {
                const sigInputRaw = parsedHeaders["signature-input"]?.data;
                const sigRaw = parsedHeaders["signature"]?.data;
                if (!sigInputRaw || !sigRaw) return false;

                // Stash for buildSigningString
                response.signatureInputRaw = sigInputRaw;

                // Parse inputs + signatures
                const entries = parseSignatureInput(sigInputRaw);
                console.log(entries);
                const sigParts = parseSignatureHeader(sigRaw);
                console.log(sigParts);

                // Pick the RSA-PSS-SHA512 entry
                const entry = entries.find(
                    (e) => e.alg.toLowerCase() === "rsa-pss-sha512"
                );
                if (!entry) return false;

                // Get the matching signature
                const sigObj = sigParts.find((s) => s.label === entry.label);
                if (!sigObj) return false;
                const signatureBytes = base64UrlToUint8Array(sigObj.sig);

                console.log(signatureBytes);

                // Import the public key (SPKI DER)
                const pubKeyBytes = base64UrlToUint8Array(entry.keyid);
                console.log(pubKeyBytes);
                const publicKey = await crypto.subtle.importKey(
                    "spki",
                    pubKeyBytes,
                    { name: "RSA-PSS", hash: "SHA-512" },
                    false,
                    ["verify"]
                );

                console.log(publicKey);

                // Build the signing string
                const signingString = buildSigningString(
                    entry,
                    parsedHeaders,
                    response
                );
                const data = new TextEncoder().encode(signingString);

                // Verify with RSA-PSS / SHA-512
                const ok = await crypto.subtle.verify(
                    { name: "RSA-PSS", saltLength: 64 },
                    publicKey,
                    signatureBytes,
                    data
                );
                return ok;
            }

            function parseHeaders(input) {
                const out = {};
                input
                    .split("\n")
                    .map((l) => l.trim())
                    .filter((l) => l && l.includes(":"))
                    .forEach((line) => {
                        const idx = line.indexOf(":");
                        const key = line.slice(0, idx).trim();
                        const val = line.slice(idx + 1).trim();
                        out[key] = { data: val };
                        if (key.includes("+link")) out[key].isLink = true;
                    });
                return out;
            }

            /**
             * Parse a Signature-Input header value into structured entries.
             * @param {string} inputHeader – the raw Signature-Input header *value* (no “Signature-Input:” prefix)
             */
            function parseSignatureInput(inputHeader) {
                return inputHeader.split(/\s*,\s*/).map((entry) => {
                    // Label is everything before the first '='
                    const eq = entry.indexOf("=");
                    const label = entry.slice(0, eq).trim();

                    // Fields are inside the first "(...)"
                    const parenMatch = entry.match(/=\(\s*([^)]+)\s*\)/);
                    const fields = parenMatch
                        ? Array.from(
                              parenMatch[1].matchAll(/"([^"]+)"/g),
                              (m) => m[1]
                          )
                        : [];

                    // Pull out any ;key="value" pairs
                    const paramRegex = /;\s*([^=;\s]+)\s*=\s*"([^"]*)"/g;
                    const params = {};
                    let m;
                    while ((m = paramRegex.exec(entry)) !== null) {
                        params[m[1]] = m[2];
                    }

                    return {
                        label,
                        fields,
                        alg: params.alg || "",
                        keyid: params.keyid || "",
                        ...(params.tag ? { tag: params.tag } : {}),
                    };
                });
            }

            /**
             * Parse the Signature header into {label, sig}[]
             */
            function parseSignatureHeader(sigRaw) {
                return sigRaw.split(/\s*,\s*/).map((part) => {
                    const [label, rest] = part.split("=");
                    // drop leading/trailing colons, e.g. :BASE64URL:
                    const sig = rest.replace(/^:+|:+$/g, "");
                    return { label, sig };
                });
            }

            function joinHeaders(headers) {
                return Array.from(headers.entries())
                    .map(([name, value]) => `${name}: ${value}`)
                    .join("\n");
            }

            /**
             * Given your parsed headers object (from parseHeaders) and the raw
             * Signature-Input header value, return a new object containing
             * only those headers which were covered by the signature-input.
             */
            function filterSignedHeaders(parsedHeaders, signatureInputValue) {
                const sigInputs = parseSignatureInput(signatureInputValue);

                // Collect all the field names covered
                const covered = new Set(
                    sigInputs.flatMap((si) =>
                        si.fields.map((f) => f.toLowerCase())
                    )
                );

                // Filter parsedHeaders keys by membership in covered
                return Object.fromEntries(
                    Object.entries(parsedHeaders).filter(([headerName]) =>
                        covered.has(headerName.toLowerCase())
                    )
                );
            }

            /**
             * @param {string} sigInputRaw
             * @returns {Promise<string>} the derived “address” of the first non-HMAC signer
             */
            async function getSignerAddress(sigInputRaw) {
                const entries = parseSignatureInput(sigInputRaw);
                if (!entries.length) return "Unknown";

                // Pick the first entry whose alg isn’t hmac-sha256 (i.e. the real pubkey)
                const realEntry =
                    entries.find(
                        (e) => e.alg.toLowerCase() !== "hmac-sha256"
                    ) || entries[0];
                const rawKeyId = realEntry.keyid;
                console.log("using keyid:", rawKeyId);

                // Now decode it to bytes (base64url → Uint8Array)
                const pubKeyBytes = base64UrlToUint8Array(rawKeyId);

                // sha-256 the public key bytes
                const hash = await crypto.subtle.digest("SHA-256", pubKeyBytes);
                const hashArr = new Uint8Array(hash);

                // base64url-encode the hash to get your “address”
                const address = btoa(String.fromCharCode(...hashArr))
                    .replace(/\+/g, "-")
                    .replace(/\//g, "_")
                    .replace(/=+$/, "");

                return address;
            }

            /** Decode base64url string → Uint8Array */
            function base64UrlToUint8Array(b64url) {
                let b64 = b64url.replace(/-/g, "+").replace(/_/g, "/");
                // Pad to multiple of 4
                while (b64.length % 4) b64 += "=";
                const bin = atob(b64);
                const arr = new Uint8Array(bin.length);
                for (let i = 0; i < bin.length; i++) {
                    arr[i] = bin.charCodeAt(i);
                }
                return arr;
            }

            async function renderExplorer(container, parsed, depth = 0) {
                const body = document.createElement("div");
                body.className = "explorer-body";

                Object.entries(parsed).forEach(
                    ([headerKey, { data, isLink }], idx, arr) => {
                        const wrapper = document.createElement("div");
                        wrapper.className = "explorer-body-row-wrapper";

                        const row = document.createElement("div");
                        row.className = "explorer-body-row";
                        row.style.paddingLeft = `${depth * 20 + 15}px`;

                        let arrow, nestedBody;
                        if (isLink) {
                            row.classList.add("explorer-action");

                            arrow = document.createElement("span");
                            arrow.className = "explorer-body-row-indicator";
                            row.appendChild(arrow);

                            wrapper._loaded = false;
                            wrapper._isOpen = false;

                            row.addEventListener("click", async () => {
                                if (!wrapper._loaded) {
                                    wrapper._loaded = true;
                                    try {
                                        const res = await fetch(`${window.location.origin}/${data}`);
                                        const raw = joinHeaders(res.headers).trim();
                                        const child = parseHeaders(raw);

                                        await renderExplorer(
                                            nestedBody,
                                            child,
                                            depth + 1
                                        );
                                    } catch (e) {
                                        console.error("Fetch failed:", e);
                                    }
                                    wrapper._isOpen = true;
                                    nestedBody.style.display = "flex";
                                    row.classList.add("explorer-body-row-open");
                                    arrow.classList.add(
                                        "explorer-body-row-indicator-open"
                                    );
                                } else {
                                    wrapper._isOpen = !wrapper._isOpen;
                                    if (wrapper._isOpen) {
                                        nestedBody.style.display = "flex";
                                        row.classList.add(
                                            "explorer-body-row-open"
                                        );
                                        arrow.classList.add(
                                            "explorer-body-row-indicator-open"
                                        );
                                    } else {
                                        nestedBody.style.display = "none";
                                        row.classList.remove(
                                            "explorer-body-row-open"
                                        );
                                        arrow.classList.remove(
                                            "explorer-body-row-indicator-open"
                                        );
                                    }
                                }
                            });
                        }

                        const keySpan = document.createElement("span");
                        keySpan.textContent = headerKey + ":";
                        row.appendChild(keySpan);

                        const value = document.createElement("p");
                        if (isLink)
                            value.classList.add("explorer-body-link-value");
                        value.textContent = data;
                        row.appendChild(value);

                        wrapper.appendChild(row);

                        nestedBody = document.createElement("div");
                        nestedBody.className = "explorer-body";
                        nestedBody.style.display = "none";
                        wrapper.appendChild(nestedBody);

                        body.appendChild(wrapper);
                    }
                );

                container.appendChild(body);
            }

            function renderSignature(signature, signer, isValid) {
                const wrapper = document.querySelector(".signature-wrapper");
                
                while (wrapper.firstChild) {
                    wrapper.removeChild(wrapper.firstChild);
                }

                const signatureLine = document.createElement("div");
                signatureLine.classList.add("signature-line");

                const signatureKey = document.createElement("span");
                signatureKey.innerText = "Signature";
                signatureLine.appendChild(signatureKey);

                const signatureValue = document.createElement("p");
                signatureValue.innerText = signature;
                signatureLine.appendChild(signatureValue);

                // const statusLine = document.createElement("div");
                // statusLine.classList.add("signature-line");

                // const statusKey = document.createElement("span");
                // statusKey.innerText = "Status";
                // statusLine.appendChild(statusKey);

                // const statusValue = document.createElement("p");
                // statusValue.classList.add("status-indicator");
                // statusValue.innerText = isValid ? "Verified" : "Invalid";
                // statusLine.appendChild(statusValue);

                const signerLine = document.createElement("div");
                signerLine.classList.add("signature-line");

                const signerKey = document.createElement("span");
                signerKey.innerText = "Signer";
                signerLine.appendChild(signerKey);

                const signerValue = document.createElement("p");
                signerValue.classList.add("tx-address");
                signerValue.innerText = signer;
                signerLine.appendChild(signerValue);

                wrapper.appendChild(signatureLine);
                // wrapper.appendChild(statusLine);
                wrapper.appendChild(signerLine);
            }

            async function renderInitialMessage() {
                const res = await fetch(window.location.href);
                const raw = joinHeaders(res.headers).trim();
                const parsed = parseHeaders(raw);

                // const isValid = await verifySignature(parsed, res);

                const signature = res.headers.get("signature");
                if (signature) {
                    console.log(parsed["signature-input"]);
                    const signatureInput =
                        parsed["signature-input"]?.data ?? "";

                    const signer = signatureInput
                        ? await getSignerAddress(signatureInput)
                        : "Unknown";

                    renderSignature(signature, signer, true);
                }

                // Get the signature-input header string
                const sigInputRaw = parsed["signature-input"]?.data;

                // If it's missing, render everything
                const toRender = sigInputRaw
                    ? filterSignedHeaders(parsed, sigInputRaw)
                    : parsed;

                renderExplorer(
                    document.getElementById("signed-headers-explorer"),
                    toRender,
                    0
                );

                document.getElementById(
                    "headers-explorer-footer-value"
                ).innerText = `(${Object.keys(toRender).length}) Headers`;

                let links = {};
                for (const key of Object.keys(parsed)) {
                    if (key.includes("+link")) {
                        links[key] = parsed[key];
                    }
                }

                if (Object.keys(links).length > 0) {
                    renderExplorer(
                        document.getElementById("links-explorer"),
                        links,
                        0
                    );

                    document.getElementById(
                        "links-explorer-footer-value"
                    ).innerText = `(${Object.keys(links).length}) Links`;
                }
            }

            renderInitialMessage();
        </script>
    </body>
</html>
